{
  "title": "Chapter 16. Specialization and Overloading",
  "cells": [
    {
      "type": "text",
      "data": "<div>So far we have studied how C++ templates allow a generic definition to be expand into a family of related classes, functions, or variables.&nbsp;</div><div>여태가지 c++ template 가 관련된 class, 함수 변수의 집합을 어떻게 generic definition 으로 확장하는지 살펴 보았다.</div><div><br></div><div>Although this is powerful mechanism, there are many situations in which the generic form of an operation is far from optimal for a specific substitution of template parameters.</div><div>이런 강력한 mechanism 에도 불구 하고&nbsp;<span style=\"color: rgb(48, 48, 48); font-family: Helvetica, Arial, sans-serif; font-size: 14.666666984558105px; white-space: pre-wrap; background-color: rgb(245, 245, 245);\">작업의 일반적인 형식이 템플릿 매개 변수를 특정 대체에 적합하지 많은 상황이 존재한다.</span></div><div><br></div><div>&nbsp;C++ is somewhat unique among other popular programming languages wich support for generic programming&nbsp;</div><div>c++ 은 generic programming 을 지원하는 다른 유명한 프로그래밍 언어 보다 독특한점이 있다.</div><div>because it has a rich set of features the enable the transparent replacement of a generic definition by a more specialized facility.&nbsp;</div><div>왜나하면 더 많은 특별한된 기능들 통하여 generic 정의를 투명하게 변경 가능한 다양한 기능의 셋을 가지고 있다.</div><div><br></div><div>In this chapter we study the two C++ language mechanisms that allow pragmatic deviations from pure generic-ness: template &nbsp;specialization and overloading of function templates.</div><div>이 챕터에서 2가지 c++ 언어 mechanisms 를 살펴 볼것이다.</div><div><span style=\"color: rgb(48, 48, 48); font-family: Helvetica, Arial, sans-serif; font-size: 14.666666984558105px; white-space: pre-wrap; background-color: rgb(245, 245, 245);\">pure generic-ness 로 부터 실욜적인 편차 : 템플릿의 특수화 </span>과 function template 의 overloading</div><div><br></div>"
    },
    {
      "type": "markdown",
      "data": "So far we have studied how C++ templates allow a generic definition to be expand into a family of related classes, functions, or variables. \n여태가지 c++ template 가 관련된 class, 함수 변수의 집합을 어떻게 generic definition 으로 확장하는지 살펴 보았다.\n\nAlthough this is powerful mechanism, there are many situations in which the generic form of an operation is far from optimal for a specific substitution of template parameters.\n이런 강력한 mechanism 에도 불구 하고 작업의 일반적인 형식이 템플릿 매개 변수를 특정 대체에 적합하지 많은 상황이 존재한다.\n\n C++ is somewhat unique among other popular programming languages wich support for generic programming \nc++ 은 generic programming 을 지원하는 다른 유명한 프로그래밍 언어 보다 독특한점이 있다.\nbecause it has a rich set of features the enable the transparent replacement of a generic definition by a more specialized facility. \n왜나하면 더 많은 특별한된 기능들 통하여 generic 정의를 투명하게 변경 가능한 다양한 기능의 셋을 가지고 있다.\n\nIn this chapter we study the two C++ language mechanisms that allow pragmatic deviations from pure generic-ness: template  specialization and overloading of function templates.\n이 챕터에서 2가지 c++ 언어 mechanisms 를 살펴 볼것이다.\npure generic-ness 로 부터 실욜적인 편차 : 템플릿의 특수화 과 function template 의 overloading\n\n16.1 when \"generic code cut\" doesn't quite cut it\n```c++\ntemplate<typename T>\nclass Array {\nprivate:\n    T * data;\n    ...\npublic:\n    Array( Array<T> cont & );\n    Array<T> & operator= ( Array<T> const & );\n    \n    void exchangeWith( Array<T> * b )\n    {\n        T * tmp = data;\n        data = b->data;\n        b->data = tmp;\n    }\n    \n    T & operator[] ( std::size_t k )\n    {\n        return data[k];\n    }\n    ...\n};\n\ntemplate<typename T>\ninline void exchange( T * a, T * b )\n{\n    T tmp( *a );\n    *a= *b;\n    *b = tmp;\n}\n```\n\nFor simple types, the generic implementation of exchange() works well.\n일반적인 타입들은 exchange() 의 generic 구현이 동작을 잘한다.\n\nhowever, for types with expensive copy operations, the generic implementation may be much more expensive \n(both in terms of machine cycles and in terms of memory usage)\nthan an implementation that is tailored to the particular, given structure.\n그러나 비싼 복사 생성자를 가지고 있는 타입들은 generic 구현이 구체적으로 맞추어진 구현보다 비싸질것이다.\n\nIn our example, the generic implementation requires on call to the copy constructor of Array<T> and\ntwo calls to its copy-assignment operator.\n우리 예에서 generic 구현은 Array<T> 의 복사 생성자의 호출과 그것의 copy-assignment operaotr 호출의 2개가필요로 한다. \n\nfor large data strcutures these copies can often involve copying relatively large amounts of memory.\n큰 data strcuture 들은 관련된 큰 크기의 메모리 복사를 포함할수 있다.\n\nhowever, the functionality of exchange() could presumably often be replaced just by swapping the internal data pointers,\nas is done in the member function exchangeWith().\n그러나 exchange () 의 기능은 exchangeWith() 멤버 함수가 하는것 처럼 아마 단지 내부 data pointer 들을 교환할수도 있다.\n\n16.1.1 Transparent Customization\nIn our previous example, the member function exchangeWidth() provides an efficient alternative to the generic exchange() function, \nbut the need to use a different function is inconvenient in several ways:\n1. User of the Array class have to remember an extra interface and must be careful to use if when possible.\n2. Generic algorithms can generally not discriminate between various possiblilities.\nFor example\n\n```c++\ntemplate<typename T>\nvoid genericAlgorithm( T * x, T * y )\n{\n...\n    exchange( x, y );   // how do we select the right algorithm?\n...\n}\n```\nBecause of these considerations, C++ templates provide ways to customize function templates and class templates transparently. \nFor function templates, this is achieved through the overloading mechanism.\nFor example, we can write an overloaded set of quickExchange() function templates as follows:\n```c++\ntemplate<typename T>\nvoid quickExchange( T * a, T * b )      // #1\n{\n    T tmp( *a );\n    *a = *b;\n    *b = tmp;\n}\n\ntemplate<typename T>\nvoid quickExchange( Array<T> * a, Array<T> * b )    // #2\n{\n    a->exchangedWith( b );\n}\n\nvoid demo( Array<int> * p1, Array<int> * p2 )\n{\n    int x = 42, y = -7;\n    quickExchange( &x, &y );        // uses #1\n    quickExchange( p1, p2 );        // uses #2\n}\n```\nThe first call to quickExchange() has two arguments of type int *, and therefore deduction succeeds only with the first template,\ndeclared at point #1, whe T is subsituted by int. \nThere is therefore no doubt regarding which function should be called.\nIn contrast, the second call can be matched with either template:\nViable functions for the call quickExchange( p1, p2 ) are obtained both when subsitituting Array<int> for T in the first template and when substituting int in second template. \nFurthermore, both substitutions result in functions with parameter types that exactly match the argument types of the second call.\nOrdinarily, this would lead us to conclude tha the call is ambiguous, but ( as we will discuss later ) the C++ language considers the second template to be \"more specailized\" than the first.\nAll other things being equal, overloaded resolution prefers the more specialized template and hence selects the template at point #2.\n\n16.1.2 Semantic Transparency\nThe use of overloading as shown in the previous section is very useful in achieving tranparent customization of the instantiation process, \nbut it is important to realize that this \"transparency\" depends a great deal on the details of the implementation.\nTo illustrate this, considier our quickExchange() solution.\nAlthough both the generic algorithm and the one customized for Array<T> types end up swapping the values that are being pointed to, the side effects of the operations are very different.\nThis is dramatically illustrated by considering some code that compares the exchange of struct objects with the exchange of Array<T>s:\n```c++\nstruct S {\n    int x;\n} s1, s2;\n\nvoid distinguish( Array<int> a1, Array int a2 )\n{\n    int * p = &a1[0];\n    int * q = &s1.x;\n    \n    a1[0] = s1.x = 1;\n    a2[0] = s2.x = 2;\n    \n    quickExchange( &a1, &a2 );      // *p == 1 after this \n    quickExchange( &s1, &s2);       // *q == 2 after this\n}\n```\nThis example shows that a pointer p into the first Array becomes a pointer into the second array after quickExchange() is called.\nHowever, the pointer into the non-Array s1 remains pointing into s1 even after the exchange operation:\nOnly the values that were pointed to were exchaged.\nThe difference is significant enough that it may confuse clients of the template implementation.\nThe prefix quick_ is helpful in attracting attention to the fact that a shortcut may be taken to realize the desired operation.\nHowever, the original generic exchange() template can still have a useful optimization for Array<T>s:\n```c++\ntemplate<typname T>\nvoid exchange( Array<T> * a, Array<T> * b )\n{\n    T * p = &(*a)[0];\n    T * q = &(*b)[0];\n    \n    for ( std::size_t k = a->size(); k-- != 0; )\n    {\n        exchange( p++, q++ );\n    }\n}\n```\n\nThe advantage of this version over the generic code is that no(potentailly) large temporary Array<T> is needed.\nThe exchange() template is called recursively so that good performance is achieved even for types such as Array<Array<char>>.\nNote also that the more specialized version of the template is not declared inline because it does a considerable amount of work of its own, whereas the original generic implementation is inline because it performs only a few operations( each of which is potentially expensive ).\n\n16.2 Overloading Function Templates\nIn the previous section we saw that two function templates with same name can coexist, even though they may be instantiaed so that both have identical parameter types.\nHere is another simple example of this:\n```c++\ntemplate<typename T>\nint f( T )\n{\n    return 1;\n}\n\ntemplate<typename T>\nint f( T* )\n{\n    return 2;\n}\n```\nWhen T is substituted by int * in the first template, a function is obtained that has exactly the same paramenter ( and returns ) types as the one obtained by substituting int for T in second template.\nNot only can these templates coexist, their respective instantiations can coexist even if they identical parameter and return types.\n The following demonstrates how two such generated functions can be called using explicit template argument syntax( assuming the previous template declaration)\n```c++\n#include <iostream>\n#include \"funcoverload1.hpp\"\n\nint main()\n{\n    std::cout << f<int*>((int*)nullptr);    // calls f<T>(T)\n    std::cout << f<int>((int*)nullptr);     // calls f<T>(T*)\n}\n```\n\nTo clarify this, let's analyze the call f<int*>((int*)nullptr) in detail. \nThe syntax f<int*>() indicates that we want to substitute the first template parameter of the template f() with int * without relying on template argument deduction. \nIn this case there is more than one template f(), and therefore an overload set is created containing two functions generated from templates:\nf<int*>(int*) (generated from the first template) and f<int*>(int**) (generated from the second template).\nThe argument to the call (int*)nullptr has type int *.\nThis matches only the function generated from the first template, and hence that is the function that ends up being called.\nFor the second call, on the other hand, the created overloading set contains f<int>(int) (generated from the first template) and f<int>(int*) (generated from second template), so that only the seconde template matches.\n\n16.2.1 Signatures\nTwo functions can coexist in a program if they have distinct signatures. \nWe define the signature of a function as the following information:/\n1. The unqualified name of the function( or the name of the function template from which it was generated)\n2. The class or namepspace scope of that name is declared.\n3. The const, volatile, or const volatile qualification of the function( if it is a member fucntion with such a qualifier)\n4. The & or && qualification of the function( if it is a memeber function with such a qualifier)\n5. The types of the function pararmetersn(before template parameters are substituted if the function is generated from a function template)\n6. Its return type, if the function is generated from a function template\n7. The template parameters and the template arguments, if the function is generated from a function template \n\nThis means that the following templates and theirs instantiations could, in principle, coexist in the same prorgram\n\n```c++\ntemplate<typename T1, typename T2>\nvoid f1 ( T1, T2 );\n\ntemplate<typename T1, typename T2>\nvoid f1 ( T2, T1 );\n\ntemplate<typename T>\nlong f2( T );\n\ntemplate<typename T>\nchar f2( T );\n```\n\nHowever they cannot always be used when they're decalred in the same scope because instantiating both creates an overload ambiguity.\nFor example, calling f2(42) when both the templates above are declared will clearly create an ambiguity.\nAnother example is illustrated below:\n\n```c++\n#include <iostream>\n\ntemplate<typename T1, typename T2>\nvoid f1( T1, T2 )\n{\n    std::cout << \"f1( T1, T2 )\\n\";\n}\n\ntemplate<typename T1, typename T2>\nvoid f1( T2, T1 )\n{\n    std::cout << \"f1( T2, T1 )\\n\";\n}\n\n// fine so far\nint main()\n{\n    f1<char, char>( 'a', 'b' );     // Error: ambigous\n}\n```\n\n```c++\ntemplate<typename T1, typename T2>\nvoid f1( T1, T2 )\n{\n    std::cout << \"f1(T1, T2)\\n\";\n}\n\ntemplate<typename T1, typename T2>\nvoid f1( T2, T1 )\n{\n    std::cout << \"f1( T2, T1 )\\n\";\n}\n\n// fine so far\nint main()\n{\n    f1<char, char>( 'a', 'b' );     // ERROR: ambiguous\n}\n```\n\nHere, the function\n\n```c++\nf1<T1 = char, T2 = char>(T1, T2)\n```\ncan coexist with the fucntion\n\n```c++\nf1<T1 = char, T2 = char>(T2, T1)\n```\n\nbut overloaded resolution will never prefer one over the other.\nIf the templates applear in differnet translation units, then the two instantiations can actaually exist in the same program( and, e.g., a linker should not complain about duplicate definitions because the signatures of the instantiations are distinct):\n\n```c++\n// translation unit1:\n#include <iostream>\n\ntemplate<typename T1, typename T2>\nvoid f1( T1, T2 )\n{\n    std::cout << \"f1( T1, T2 )\\n\";\n}\n\nvoid g()\n{\n    f1<char, char>( 'a', 'b' );\n}\n\n// translation unit 2:\n#include <iostream>\ntemplate<typename T1, typename T2>\nvoid f1( T2, T1 )\n{\n    std::cout << \"f1( T2, T1 )\\n\" );\n}\n\nextern void g();        // defined in translation unit 1\n\nint main()\n{\n    f1<char, char>( 'a', 'b'b );\n    g();\n}\n```\n\nThis program is valid and produces the following output: \n```c++\nf1( T2, T1 )\nf1( T1, T2 )\n```\n\n16.2.2 Partial ordering of overloaded Function Templates\n\nReconsider our earlier example: We found that after substituting the given template argument lists(<int*> and <int> ), overload resolution ended up selecting the right function to call\n\n```c++\nstd::cout << f<int*>((int*)nullptr);    // calls f<T>(T)\nstd::cout << f<int>((int*)nulltpr);     // calls f<T>(T*)\n```\n\nHowever, a function is selected even when explicit template arguments are not provided. In this case, template argument deduction comes into play. Let's slightly modify function main() in the previous example to discuss this mechanism:\n\n```c++\n#include <iostream>\n\ntemplate<typename T>\nint f( T )\n{\n    return 1;\n}\n\ntemplate<typename T>\nint f( T* )\n{\n    return 2;\n}\n\nint main()\n{\n    std::cout << f( 0 );            // calls f<T>( T )\n    std::cout << f( nullptr );      // calls f<T>( T )\n    std::cout << f((int*)nulltpr )  // calls f<T>( T* )\n```\n\nConsider the first call, f(0): Tye type of the argument is int, which matches the type of the parameter of the first template if we substitute T with int.\nHowever, the parameter type of the second template is always a pointer and, hence, after deduction, only an instance generated from the first template is a candidate for the call. In this case overload resolution is trival.\n The same applies to the second call: (f(nullptr): The type of the argument is std::nullptr_t, which again only matches for the first template.\n The third call (f( ( int* ) nullptr )) is more interesting: Argument deduction succeeds for both templates, yielding the functions f<int*>(int*) and f<int>(int*).\n From a traditional overload resolution perspective, both are equally good functions to call with an int* argument, which would suggest that the call is ambigous(See appendix C). However, in this sort of case, an additinal overload resolution criterion comes into play: The function generated from the more specialized template is selected. Here( as we see shortly ), the second template is considered more specialized and thus the output of out example is 112.\n \n16.2.3 Formal Ordering Rules\nIn out last example, it may seem very intuitive that the second template is more special than the first because the first can accommodate just about any argument type, whereas the second allows only pointer types. However, other examples are not necessarily as intuitive, In what follow, we\n402 -- 446\n"
    },
    {
      "type": "markdown",
      "data": ""
    }
  ]
}