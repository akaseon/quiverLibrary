{
  "title": "No.30 인라인 함수는 미주알고주알 따져서 이해해 두자.",
  "cells": [
    {
      "type": "markdown",
      "data": "인라인 함수는 \n- 함수처럼 보이고 함수처럼 동작\n- 매크로보다 훨씬 안전하고 쓰기 좋음\n- 함수 호출시 발생하는 오버헤드 걱정 필요 없음\n- 컴파일러가 함수 본문에 대해 문맥별 최적화(Context-specific)에 용이\n- 인라인 함수는 함수 호출문은 그 함수 본문으로 변경\n\n컴파일러 최적화는 \n- 함수 호출이 없는 코드가 연속적으로 이어지는 구간에 적용 되도록 설계\n- 컴파일러는 아웃라인 함수 호출에 대해 이런 최적화를 적용하지 않음\n> 아웃라인 함수 : 일반적인 함수 호출\n\n\n인라인 함수 남발할 경우\n- (단점) 메모리가 제한된 컴퓨터에서는 프로그램 크기가 그 기계에서 쓸수 있는 공간을 넘어 버릴수 있음\n- (단점) 가상 메모리를 쓰는 환경에서는 \n    - 인라인 함수로 부풀려진 코드는 성능의 걸림돌이 되기 쉽다.\n    - 페이징 횟수가 늘어나고 명령어 캐시 적중률이 떨어짐\n- (장점) 본문 길이가 굉장히 짧은 인라인 함수를 사용하면 함수 본문에 대해 만들어지는 코드의 크기가 함수 호출문에 대해 만들어진 코드보다 작아질수 있음\n    - 이럴 경우 목적 코드의 크기도 작아지며 명령어 캐시 적중률도 높아짐\n    - 함수 호출과 반환값 처리하는 것도 비용\n\n인라인은 컴파일러에 '요청'을 하는것이지, 명령이 아님\n- 이런 요청은 컴파일러가 그냥 하는 경우(암시적 선언)\n- 사용자가 적접 컴파일러에게 요청(명시적 선언)으로 인한 것 \n\n암시적 선언\n```c++\nclass Person {\npublic:\n    ...\n    int age() const { return theAge; }  // 암시적 인라인 요청\n                                        // age 는 클래스 정의 내부에 정의\n    ...\nprivate:\n    int theAge;\n};\n```\n\n명시적 선언\n- 함수 정의 앞에 inline 키워드를 추가\n\n```c++\ntemplate<typename T>\ninline const T& std::max( const T& a, const T& b )\n{ return a < b ? b : a; }\n```\n\n인라인 함수는 대체적으로 헤더파일에 위치하는 이유\n- 대부분의 빌드 환경에서 인라인을 컴파일 도중에 수행\n- 인라인 함수 호출은 그 함수의 본문으로 바꿔치기 하려면 일단 컴파일러가 어떤 형태인지 알고 있어야 함\n\n인라인은 컴파일러 선에서 무시할수 있는 요청\n- 컴파일러가 보기에 복잡한 함수는 절대 인라인 확장의 대상에 넣지 않음(루프나 재귀)\n- 간단한 함수라도 가상 함수 호출같은 것은 절대 인리인 안됨\n    - virtual 의 의미가 \"어떤 함수를 호출하지 결정하는 작업을 실행중에 결정\"\n    - inline 의 의미가 \"함수 호출 위치에 호출된 함수를 끼워 넣는 작업을 실행 전에 수행\"\n\n함수에 대한 인라인이 실패 했을 경우 경고 메시지를 출력\n\n인라인 함수의 주소를 취하는 코드가 있으면 컴파일러는 이 코드를 위해 인라인 함수를 아웃라인 함수로 생성 \n인라인 함수로 선언된 함수를 함수 포인터를 통해 호출하는 경우에 인라인화 되지 않음\n\n```c++\ninline void f() { ... } // 이 f()의 호출은 컴파일러가 반드시 인리인화를 수행\n\nvoid (*pf)() = f;       // pf 는 f() 을 가리키는 함수 포인터\n..\nf();                    // 인라인화 \n\npf();                   // 인라인화 되지 않음\n                        // 함수 포인터를 통하여 호출\n```\n\n생성자와 소멸자는 인라인하기에 좋지 않은 함수 \n\n```c++\nclass Base {\npublic:\n    ...\nprivate:\n    std::string bm1, bm2;\n};\n\nclass Derived : public Base {\npublic:\n    Derived() { };\n    ...\nprivate:\n    std::string dm1, dm2, dm3;\n};\n```\nc++ 은 '무엇을' 해야 하는지는 정해 두었지만 그것을 '어떻게' 해야 하는지는 정해 놓지 않음\n'어떻게' 부분은 컴파일러 구현자에게 달려 있음 \n\n실제 호출은 아래와 비슷\n```c++\nDerived::Derived()\n{\n    Base::Base();\n    \n    try { dm1.std::string::string();\n    } catch ( ... ) {\n        Base:~Base();\n        throw;\n    }\n    \n    try { dm2.std::string::string();\n    } catch ( ... ) {\n        dm1.std::string::~string();\n        Base:~Base();\n        throw;\n    }\n    \n    try { dm3.std::string::string();\n    } catch ( ... ) {\n        dm2.std::string::~string();\n        dm1.std::string::~string();\n        Base:~Base();\n        throw;\n    }\n}\n```\n\n라이브러리를 설계시 함수를 인라인으로 선언할 때 \n- 그 영향에 대해 많은 고민을 해야함\n- 사용자의 눈에 뻔히 보이는 인라인 함수에 대해서는 라이브러리 차원에서 바이너리 업그레이드를 제공할수 없음\n- 라이브러리에서 인라인 함수를 사용할 경우 해당 인라인 함수가 수정 되면 라이브러리를 사용하는 코드도 다시 컴파일되어야 함\n\n우선 아무것도 인라인하지 말아야 한다. 아니면 꼭 인라인해야 하는 함수 혹은 정말 단순한 함수에 한해서만 인라인 함수로 선언하는 것으로 시작해야 한다. \n\n\n> \n1. 함수 인라인은 작고, 자주 호출되는 함수에 대해서만 하는 것으로 묶어두자. 이렇게 하면 디버깅및 라이브러리의 바이너리 업그레이드가 용이해지고, 자칫 생길 수 있는 코드 부풀림 현상이 최소화 되며, 프로그램의 속력이 더 빨라 질 수 있는 여지가 최고로 많아진다.\n2. 함수 템플릿이 대개 헤더 파일에 들어 간다는 일반적인 부분만 생각해서 이들을 인라인으로 선언하면 안된다.\n\n\n\n"
    }
  ]
}