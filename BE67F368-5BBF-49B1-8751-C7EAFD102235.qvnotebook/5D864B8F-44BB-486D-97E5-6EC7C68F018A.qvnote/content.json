{
  "title": "No.32 pulbic 삼속 모형은 반드시 “is-a” 를 따르도록 만들자",
  "cells": [
    {
      "type": "markdown",
      "data": "pulbic 상속은 \"is-a\" 를 의미\n\n클래스 D(\"Derived\")를 클래스 B(\"Base\")로 부터 public 상속을 통해 파생\n-  D 타입으로 만들어진 모든 객체는 또한 B타입의 객체지만 그 반대는 되지 않음\n    - B는 D보다 더 일반적인 개념을 나타내며, D는 B보다 더 특수한 개념을 나타냄\n    - B 타입의 객체가 쓰이는 곳에서는 D 타입의 객체도 마찬가지고 쓰일수 있음\n\n```c++\nclass Person { ... };\n\nclass Student: public Person { ... };\n```\n- 모든 학생은 사람이지만 모든 사람은 학생은 아님\n    - '사람'은 '학생'보다 더 일반적인 개념\n    - 학생은 사람을 더 특수하게 만든 한 종류\n- Person 타입의 인자를 기대하는 함수는 Student 객체도 받아들일수 있음\n\n```c++\nvoid eat( const Person & p );       // 먹는것은 누구나 가능\n\nvoid study( const Student & s )     // 학과 공부는 학생만 가능\n\nPerson p;\nStudent s;\n\neat( p );                           // p 는 Person \neat( s );                           // s 는 Student, Student는 Person의 일종\n\nstudy( s );                         // 가능\nstudy( p );                         // 불가능 p는 Student 가 아님\n```\n\npublic 상속과 is-a 관계가 똑같은 뜻이라는 이야기는 꽤 직관적이고 간단하지만 그 직관때문에 판단을 잘못하는 경우도 있음\n\n```c++\nclass Bird {\npublic:\n    virtual void fly();         // 새는 날수 있다.\n...\n};\n\nclass Penguin: public Bird {    // 펭귄은 새다.\n...\n};\n```\n위의 클래스 계통에 따르면 펭귄은 날수 있다. 그러나 이것은 맞지 않다.\n\n다음과 같이 하면 조금 더 현실에 가까운 클래스 계통구조를 보일수 있다.\n```c++\nclass Bird {\n...\n};\n\nclass FlyingBird: public Bird {\npublic:\n    virtual void fly();\n    ...\n};\n\nclass Penguin: public Bird {\n...\n};\n```\n\n펭귄의 fly 함수를 재정의해서 런타임 에러를 내도록 한다.\n```c++\nvoid error( const std::string & msg );\n\nclass Penguin: public Bird {\npublic:\n    virtual void fly() { error( \"Attempt to make a penguin fly!\" ); }\n...\n};\n```\n위의 코드는 \"펭귄은 날 수 없다\"가 아니라 \"펭귄은 날 수 있다. 그러나 펭귄이 실제 날려고 하면 에러가 난다\" 이다.\n- 컴파일러가 \"펭귄은 날 수 없다\"라고 에러를 발생시키지 않는다.\n- 런타임중에 \"펭귄이 실제 날려고 하면 에러 난다\" 를 발생 시킨다.\n\n\"펭귄은 날 수 없다\" - 제약사항\n```c++\nclass Bird {\n...             // fly 함수가 선언되지 않음\n};\n\nclass Penguin; Public Bird {\n...             // fly 함수가 선언되지 않음\n};\n\nPenguin p;\n\np.fly();        // 에러(컴파일)\n```\n\n- 유효하지 않은 코드를 컴파일 단계에서 막아주는 인터페이스가 좋은 인터페이스\n    - 유효하지 않은 코드를 컴파일 단계에서 거부하는 설계가 그것을 런타임에 뒤늦게 알아채는 설게보다 훨씬 좋다\n    - From No.18\n\n```c++\nclass Rectangle {\npublic:\n    virtual void setHeight( int newHeight );\n    vitrual void setWidth( int newWidth );\n    \n    virtual int height() const;         // 현재의 값을 반환\n    virtual int width() const;\n...\n};\n\nvoid makeBigger( Rectangle & r )        // r 의 넓이를 늘리는 함수\n{\n    int oldHeight = r.height();\n    \n    r.setWidth( r.width() + 10 );       // r 의 가로길이에 10을 더함\n    \n    assert( r.height() == oldHeight );\n}\n```\n\n```c++\nclass Square: public Rectangle { ... };\n\nSquare s;\n...\nassert( s.width() == s.height );\n\nmakeBigger( s );\n\nassert( s.width() == s.height );\n```\n\n- 조정이 필요한 assert 문\n    1. makeBigger 함수를 호출하기전에, s의 세로 길이는 가로 길이와 같아야함\n    2. makeBigger 함수가 실행되는 중에, s의 가로길이는 변하는데 세로 길이는 안 변해야함\n    3. makeBigger 함수를 호출된 이후에는, s의 가로길이와 세로길이가 같아야함\n\n\n- public 상속은 기본 클래스 객체가 가진 모든 것들이 파생 클래스 객체에도 그대로 적용 된다고 단정하는 상속 \n    - 직사각형과 정사각형의 경우 이런 단정이 참이 될수 없음\n        - 컴파일러 수전에서는 문법적 하자가 없기 때문에 이런 코드가 무사히 통과\n        - 하지만 위의 코드에서와 같이 제대로 동작한다는 의미는 아님\n\n- 클래스 사이에 맺을수 있는 관계\n    - is-a\n    - has-a\n    - is-implemented-in-term-of\n\n> public 상속의 의미는 \"is-a\" 이다. 기본 클래스에 적용되는 모든 것들이 파생 클래스에 그대로 적용되어야 한다. 왜냐하면 모든 파생 클래스 객체는 기본 클래스의 일종이기 때문이다.\n\n"
    }
  ]
}