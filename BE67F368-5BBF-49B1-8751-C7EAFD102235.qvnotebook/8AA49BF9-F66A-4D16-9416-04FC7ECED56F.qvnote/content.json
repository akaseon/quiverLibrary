{
  "title": "No.33 상속된 이름을 숨기는 일을 피하자",
  "cells": [
    {
      "type": "markdown",
      "data": "```c++\nint x;                  // 전역 변수\n\nvoid someFunc()\n{\n    double x;           // 지역 변수\n    \n    std::cin >> x;      // 지역변수에 입력된 값 저장\n}\n```\n\n컴파일러가 someFunc 함수의 유효범위 안에서 x라는 이름을 만나면 일단 컴파일러는 자신이 처리하고 있는 유효범위, 즉 지역 유효범위(local scope)를 뒤져서 같은 이름을 가진 것이 있는가 확인\n\n```c++\nclass Base {\nprivate:\n    int x;\npublic:\n    virtual void mf1 = 0;\n    virtual void mf2();\n    void mf3();\n    ...\n};\n\nclass Derived: public Base {\npublic:\n    virtual void mf1();\n    void mrf4();\n    ...\n};\n```\n\n```c++\nvoid Derived::mf4()\n{\n    ...\n    mf2();\n}\n```\n\nmf2() 를 Derived 클래스에서 검색하고 없으면 Base 클래스에서 검색\n\n```c++\nclass Base{\nprivate:\n    int x;\npublic:\n    virtual void mf1() = 0;\n    virtual void mf1( int );\n    virtaul void mf2();\n    \n    void mf3();\n    void mf3( double );\n    ...\n};\n\nclass Dervied: public Base {\npublic:\n    virtual void mf1();\n    void mf3();\n    void mf4();\n    ...\n};\n```\nBase 클래스의 mf1, mf3 함수는 Dervied 클래스에서는 Dervied 에 선언된 함수들에 의하여 가려짐\n\n```c++\nDervied d;\nint x;\n...\nd.mf1();        // OK,  Dervied::mf1 호출\nd.mf1( x );     // NOK, Dervied::mf1 이 Base::mf1 를 가림\n\nd.mf2();        // OK,  Base::mf2 호출\n\nd.mf3()         // OK,  Dervied::mf3 호출\nd.mf3( x );     // NOK, Dervied::mf3 이 Base::mf3 를 가림 \n```\n\n이렇게 동작하는 이유\n- 어떤 라이브리러 혹은 응용프로그램 프레임워크를 이용하여 파생 클래스를 하나 만들때, 멀리 떨어져 있는 기본 클래스로부터 오버로드 버전을 상속시키는 경우를 막기 위함\n- 일종의 실수로 간주\n\n가려진 이름은 using 선언으로 끄집어 낼수 있다.\n```c++\nclass Base {\nprivate:\n    int x;\n    \npublic:\n    virtual void mf1() = 0;\n    virtual void mf1( int );\n    virtual void mf();\n    void mf3();\n    void mf3( double );\n    ...\n};\n\nclass Dervied: public Base {\npublic:\n    using Base::mf1;\n    using Base::mf3;\n    \n    virtual void mf1();\n    void mf3();\n    void mf4();\n};\n```\n\n```c++\nDervied d;\nint x;\n...\nd.mf1();        // Dervied::mf1 호출\nd.mf1( x );     // Base::mf1 호출\n\nd.mf2();        // Base::mf2 호출\n\nd.mf3();        // Dervied:mf3 호출\nd.mf3( x );     // Base::mf3 호출\n```\n어떤 기본 클래스로부터 상속을 받으려고 하는데, 오버로드된 함수가 그 클래스에 들어 있고 이 함숟들 중 몇개만 재 정의하고 싶다면, 각 이름에 대해 using 선언을 붙여주어야 한다.\n\n- 기본 클래스가 가진 함수를 전부 상속하지 않았으면 하는 경우도 존재\n    - 이 경우와 public 상속을 함께 놓고 생각하지 말어야 함\n        - 기본 클래스와 파생 클래스 사이의 is-a 관계가 깨져 버린다.\n    - private 상속을 사용하면 가능함 \n        - using 선언은 그 이름에 해당하는것 들이 파생클래스로 내려가므로 안됨  \n        - 전달 함수(forwarding function)\n```c++\nclass Base {\npublic:\n    virtual void mf1() = 0;\n    virtual void mf1( int );\n    ...\n};\n\nclass Dervied: private Base {\npublic:\n    virtual void mf1()\n    {   Base::mf1();    }   // 전달 함수\n};\n...\nDervied d;\nint x;\n\nd.mf1();        // OK,  Derived::mf1 호출\nd.mf1( x );     // NOK\n```\n\n> 1. 파생 클래스의 이름은 기본 클래스의 이름을 가립니다. public 상속에서는 이런 이름 가림 현상은 바람직 하지 않는다.\n> 2. 가려진 이름을 다시 볼수 있게 하는 방법으로 using 선언 혹은 전달 함수를 쓸수 있다.\n"
    }
  ]
}