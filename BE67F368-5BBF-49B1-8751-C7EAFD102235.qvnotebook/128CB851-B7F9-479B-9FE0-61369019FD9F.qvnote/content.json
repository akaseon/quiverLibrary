{
  "title": "No.35 가상 함수 대신 쓸 것들도 생각해 두는 자세를 시시때때로 길러두자.",
  "cells": [
    {
      "type": "markdown",
      "data": "# 가상함수\n```c++\nclass GameCharacter\n{\npublic:\n    virtual int healthValue() const;    // 캐릭터의 체력치를 반환하는 함수\n                                        // 파생 클래스는 이 함수를 재 정의 가능\n...\n};\n```\n\n# 비가상 인터페이스 관용구를 통한 템플릿 메서드 패턴\n - 가상함수는 반드시 private 멤버 -> 가상 함수 은폐론\n - healthValue 를 public 멤버 함수로 그대로 두되 비 가상함수로 선언\n - 내부적으로는 실제 동작을 맡은 private 가상 함수를 호출\n - 비 가상 함수 인터페이스( non-vittual interface: NVI ) 관용구\n    - 사용자로 하여금 public 비가상 함수를 간접적으로 호출하게 만드는 방법\n    - 가상 함수가 호촐되기 전에 어떤 상태를 구성하고 가상 함수가 호출된 후에 그 상태를 없애는 작업을 이 랩터를 통해 보장\n\n```c++\nclass GameCharacter\n{\npublic:\n    int healthValue() const     // 파생 클래스는 이제 이 함수를 재정의 불가\n    {\n        ...                     // 사전 동작을 수행\n        int retVal = doHealthValue();   // 실제 동작을 수행\n        ...                     // 사후 동작을 수행\n        return retVal;\n    }\n    \n    ...\nprivate:\n    virtual int doHealthValue() const   // 파생클래스는 이 함수를 재 정의 가능\n    {\n        ...                 // 캐릭터의 체력치 계산을 위한 기본 알고리즘을 구현\n    }\n};\n```\n\n# 함수 포인터로 구현한 전략 패턴\n\n```c++\nclass GameCharacter;\n\nint defaultHealthCalc( const GameCharacter & gc );\n\nclass GameCharacter\n{\npublic:\n    typedef int (*HealthCalcFunc)( const GameCharacter & );\n    \n    explicit GameCharacter( HealthCalFunc hcf = defaultHealthCalc ) : healthFunc( hcf )\n    { }\n    \n    int healthValue() const\n    {\n        return healthFunc( *this );\n    }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n- 같은 캐릭터 타입으로 부터 만들어진 객체들도 체력치 계산 함수를 각각 다르게 가질수 있다.\n\n```c++\nclass EvilBadGuy: public GameCharacter\n{\npublic:\n    explicit EvilBadGuy( HealthCalcFunc hcf = defaultHealthCalc ) : GameCharacter( hcf )\n    {\n    ...\n    }\n    ...\n};\n\nint loseHealthQuickly( const GameCharacter & );     // 다른 동작 원리로 구현된\nint looseHealthSlowly( const GameCharacter & );     // 체력치 계산 함수들\n\nEvilBadGuy ebg1( loseHealthQuickly );               // 같은 타입인데도 \nEvilBadGuy ebg2( loseHealthSlowly );                // 체력치 변화가 다르게 나오는 캐릭터\n};\n```\n- 게임이 실행되는 도중에 특정 캐릭터에 대한 체력치 계산 함수를 변경 가능\n- 체력치 계산 함수가 이제 GameCharacter 클래스 계통의 함수가 아님\n    - 체력치가 계산 되는 대상 객체의 비공개 데이터는 이 함수로 접근할수 없다.\n    - 클래스 내부의 기능(멤버함수를 통해)을 그 클래스의 바깥에 있는 동등한 기능으로 대체..\n    - public 영역에 없는 부분을 비멤버 할수도 접근할 수 있게 하려면 그 클래스의 캡슐화를 약화시키는 방법밖에 없나는것이 일반적인 법칙\n        - 비멤버 함수를 프렌드로 선언\n        - 숨겨 놓는 것이 나을지도 모르는 세부 구현사항에 대한 접근자 함수를 public 멤버로 제공\n\n# tr1:function 으로 구현한 전략 패턴\n\n```c++\nclass GameCharacter;\nint defaultHealthCalc( const GameCharacter & gc );\n\nclass GameCharacter\n{\npublic:\n    typedef std::tr1::function<int ( const GameCharacter & ) > HealthCalcFunc;\n    \n    explicit GameCharacter( HealthCalcFunc hcf = defaultHealthCalc ) : healthFunc( hcf )\n    {\n    }\n    \n    int healthValue() const\n    {\n        return healthFunc( *this );\n    }\n    ...\nprivate:\n    HealthCalcFunc healthFunc;\n};\n```\n\n```c++\nshort calcHealth( const GameCharacter & );\n\nstruct HealthCalculator\n{\n    int operator()( const GameCharacter & ) const \n    {\n    ...\n    }\n};\n\nclass GameLevel\n{\npublic:\n    float health( const GameCharacter & ) const;\n    ...\n};\n\nclass EvilBadGuy : public GameCharacter\n{\n    ...\n};\n\nclass EyeCandyCharacter : public GameCharacter\n{\n    ...\n};\n\nEvilBadGuy ebg1( calcHealth );\n\nEyeCandyCharacter ecc1( HealthCalculator() );\n\nGameLevel currentLevel;\n...\nEvilBadGuy ebg2( std::tr1::bind( &GameLevel:health, \n                                 currentLevel,\n                                 _1 )\n                );\n\n```\n\n# '고전적인' 전략 패턴\n\n```c++\nclass GameCharacter;\n\nclass HealthCalcFunc\n{\npublic:\n    ...\n    virtual int calc( const GameCharacter & gc ) const\n    {\n    ...\n    }\n    ...\n};\n\nHealthCalcFunc defaultHealthCalc;\n\nclass GameCharacter\n{\npublic:\n    explicit GameCharacter( HealthCalcFunc * phcf = &defaultHealthCalc ) : pHealthCalc( phcf )\n    {\n    }\n    \n    int healthValue() const\n    {\n        return pHealthCalc->calc( *this );\n    }\n    ...\nprivate:\n    HealthCalcFunc *pHealthCalc;\n};\n```\nHealthCalcFunc 클래스 계통에 파생 클래스를 추가함으로써 기존 체력치 계산 알고리즘을 조정 / 개조할 수 있는 가능성을 열어 놓았음.\n\n# 요약\n어떤 문제를 해결하기 위한 설계를 찾을 때 가상 함수를 대신하는 방법들도 고려해 보자\n\n- 비가상 인터페이스 관용구를 사용\n    - 공개되지 않은 가상 함수를 비가상 public 멤버 함수로 감싸서 호출하는 템플릿 메서드 패턴의 한 예 \n- 가상함수를 함수 포인터 데이터 멤버로 대체\n    - 군더기 없이 전략 패턴의 핵심만을 보여주는 형태 \n- 가상 함수를 tr1::function 데이터 멤버를 대체\n    - 호환되는 시그니처를 가진 함수호출성 개체를 사용할수 있도록 만듬\n    - 전략 패턴의 한 예\n- 한쪽 클래스 계통에 속해 있는 가상 함수를 다른쪽 계통에 속해 있는 가상함수로 대체  \n    - 전략패턴의 전통적인 구현 형태\n\n> 1. 가상 함수 대신에 쓸 수 있는 다른 방법으로 NVI 관용구 및 전략 패턴을 들수 있다. 이중 NVI 관용구는 그 자체가 템플릿 메서드 패턴의 한예\n2. 객체에 필요한 기능을 멤버 함수로부터 클래스 외부의 비멤버 함수로 옮기면, 그 비멤버 함수는 그 클래스의 public 멤버가 아닌 것들을 접근할 수 없다는 단점이 생김\n3. tr1::function 객체는 일반화된 함수 포인터처럼 동작. 이 객체는 주어진 대상 시그니처와 호환되는 모든 함수호출성 개체를 지원"
    }
  ]
}