{
  "title": "No.34 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자.",
  "cells": [
    {
      "type": "markdown",
      "data": "- public 상속\n    - 함수 인터페이스의 상속\n    - 함수 구현의 상속\n\n```c++\nclass Shape {\npublic:\n    virtual void draw() const = 0;\n    virtual void error( const std::string & msg );\n    int objectID() const;\n    ...\n};\n\nclass Rectangle: public Shape { ... };\nclass Ellipse: public Shape { ... };\n```\n\n멤버 함수 인터페이스는 항상 상속되게 되어 있다.\n- public 상속의 의미는 is-a 이므로, 기본 클래스에 해당하는 것들은 모두 파생 클래스에 해당되어야 함\n- 어떤 클래스에 동작하는 함수는 그 클래스의 파생 클래스에서도 동작해야 함\n\nShape 클래스에는 세개의 함수가 선언\n- draw함수\n    - 암시적인 표시 장치에 현재의 객체를 그림\n    - 순수 가상 함수\n- error 함수\n    - 에러를 보고할 필요가 있을때 사용\n    - 단순 가상 함수\n- objectID 함수\n    -  주어진 객체에 붙는 유일한 정수 식별자를 반환\n    -  비가상 함수\n\n순수 가상 함수\n- 어떤 순수 가상 함수를 물려받은 구체 클래스가 해당 순수 가상 함수를 다시 선언해야함\n- 순수 가상 함수는 전형적으로 추상 클래스 안에서 정의를 갖지 않음\n\n> 순수 가상 함수를 선언하는 목적은 파생 클래스에게 함수의 인터페이스를 물려주려는 것 \n\n단순 가상 함수\n- 파생 클래스로 하여금 함수의 인터페이스를 상속하게 하다는 점은 동일\n- 파생 클래스 쪽에서 오버라이드할 수 있는 함수 구현부도 제공\n\n> 단순 가상 함수를 선언하는 목적은 파생 클래스로 하여금 함수의 인터페이스 뿐만 아니라 그 함수의 기본 구현도 물려 받게 하자는 것\n"
    }
  ]
}