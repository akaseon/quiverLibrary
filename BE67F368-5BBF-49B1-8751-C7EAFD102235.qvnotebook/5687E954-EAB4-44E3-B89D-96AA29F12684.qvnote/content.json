{
  "title": "No.42 typename 의 두가지의 의미를 제대로 파악하자",
  "cells": [
    {
      "type": "markdown",
      "data": "```c++\ntemplate<class T> class Widget;\ntemplate<typename T> class Widget;\n```\ntemplate의 타입 매개변수를 선언할때는 class 나 typename 의 뜻이 같다.\n\n```c++\ntemplate<typename C>\nvoid print2nd( const C & container )\n{\n    if ( container.size() > 2 )\n    {\n        C::const_iterator iter( container.begin() );\n        \n        ++iter;\n        int value = *iter;\n        std::cout << value;\n        \n    }\n}\n```\n\nC::const_iterator 는 template 매개변수인 C에 따라 달라지는 타입이다.\ntemplate내의 이름중 이렇게 template 매개변수에 종속된 것을 가리켜 의존 이름(dependent name)이라고 한다.\n의존 이름이 어떤 클래스 안에 중첩되어 있는 경우가 있는데, 이경우의 이름을 중첩 의존 이름(nested dependent name)이라고 한다.\nC::const_iterator는 중첩 의존 이름이다. 정확히 말하면 중첩 의존 타입 이름(nested dependent type name)이다. 타입을 참조하는 중첩 의존 이름이란 뜻이다.\n\nvalue는 int 타입이다. int는 template 매개변수와 상관 없는 타입 이름이다.\n이러한 이름을 비의존 이름(non-dependent name)이라 한다.\n\n```c++\ntemplate<typename C>\nvoid print2nd( const C & container )\n{\n    C::const_iterator * x;\n    ...\n}\n```\nC::const_iterator에 대한 포인터인 지역 변수로 x 를 선언한것 처럼 보이지만..\n그러지 않을수도 있다.\nconst_iterator 라는 이름의 정적 데이터 멤버가 C 에 존재 할수도 있다.\n그러면 C::const_iterator 정적 멤버변수와 x 를 곱셈 연산이라 여긴다.\n\nC::const_iterator 가 진짜 타입인지는 아닌지는 컴파일러가 알수 없다.\n그렇게 때문에 C++ 은 이 모호성을 해결하기 위해 template 안에 중첩 의존 이름이 나오면 기본적으로 타입이 아닌것으로 해석한다.\n\n```c++\ntemplate<typename C>\nvoid print2nd( const C & container )\n{\n    if ( container.size() > 2 )\n    {\n        C::const_iterator iter( container.begin() );    // 타입이 아닌것으로 가정\n        ...\n```\n\n그렇기 때문에 C::const_iterator 앞에 typename 키워드를 붙여서 프로그래머가 타입이라고 알려주어야 한다\n\n```c++\ntemplate<typename C>\nvoid print2nd( const C & container )\n{\n    if ( container.size() > 2 )\n    {\n        typename C::const_iterator iter( container.begin() );\n        ...\n```\n\ntypename 키워드는 중첩의존 이름만 식별하는데 써야 한다.\n\n```c++\ntemplate<typename C>                    // typename 사용가능, class 와 동일한 의미 \nvoid f( const C & container,            // typename 쓰면 안됨\n        typename C::iterator iter );    // typename 꼭 써야함\n```\n\ntypename 은 중첩의존타입이름 앞에 붙여 주어야 한다는 규칙에 예외가 하나 있다.\n중첩의존타입이름이 기본 클래스의 리스트에 있거나 멤버 초기화 리스트내의 기본 클래스 식별자로서 있을 경우 typename 을 붙여주면 안된다.\n\n```c++\ntemplate<typename T>\nclass Dervived: public Base<T>::Nested                  // 상속되는 기본 클래스 리스트, typename 쓰면 안됨\n{\npublic:\n    explicit Dervied( int x ): Base<T>::Nested( x )     // 멤버초기화 리스트에 있는 기본 클래스 리스트, 클래스 식별자::typename 사용하면 안됨\n    {\n        typename Base<T>::Nested temp;                  // 중첩의존타입이름이며, \n                                                        // 기본클래스 리스트에 없고 \n                                                        //멤버초기화 리스트의 기본 클래스 식별자도 아니므로 \n                                                        // typename 필요\n    }\n};\n```\n\n```c++\ntemplate<typename IterT>\nvoid workWithIterator( IterT iter )\n{\n    typename std::iterator_traits<IterT>::value_type temp( *iter );\n    ...\n}\n```\n\n```c++\ntemplate<typename IterT>\nvoid workWithIterator( IterT iter )\n{\n    typedef typename std::iterator_traits<IterT>::value_type value_type;\n    \n    value_type temp( *iter );\n    ...\n}\n```\n\n> template 매개변수를 선언할때 class 및 typename 은 서로 바꾸어 써도 된다.\n> 중첩의존타입으름을 식별하는 용도에는 반드시 typename 을 사용한다.중첩의존이름이 기본클래스 리스트에 있거나 멤버 초기화 리스트내의 기본 클래스 식별자로 있는 경우는 예외이다."
    }
  ]
}